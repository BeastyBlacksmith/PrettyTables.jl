<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · Pretty Tables</title><link rel="canonical" href="https://ronisbr.github.io/PrettyTables.jl/stable/man/usage/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Pretty Tables logo"/></a><h1>Pretty Tables</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li class="current"><a class="toctext" href>Usage</a><ul class="internal"><li><a class="toctext" href="#Crayons-1">Crayons</a></li><li><a class="toctext" href="#Cropping-1">Cropping</a></li><li><a class="toctext" href="#Helpers-1">Helpers</a></li></ul></li><li><a class="toctext" href="../alignment/">Alignment</a></li><li><a class="toctext" href="../filters/">Filters</a></li><li><a class="toctext" href="../formats/">Formats</a></li><li><a class="toctext" href="../formatter/">Formatters</a></li><li><a class="toctext" href="../highlighters/">Highlighters</a></li><li><a class="toctext" href="../examples/">Examples</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Usage</a></li></ul><a class="edit-page" href="https://github.com/ronisbr/PrettyTables.jl/blob/master/docs/src/man/usage.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Usage</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h1><p>The following functions can be used to print data.</p><pre><code class="language-julia">function pretty_table([io::IO,] data::AbstractVecOrMat{T1}, header::AbstractVecOrMat{T2}, tf::PrettyTableFormat = unicode; kwargs...) where {T1,T2}</code></pre><p>Print to <code>io</code> the vector or matrix <code>data</code> with header <code>header</code> using the format <code>tf</code> (see <a href="../formats/#Formats-1">Formats</a>). If <code>io</code> is omitted, then it defaults to <code>stdout</code>. If <code>header</code> is empty, then it will be automatically filled with &quot;Col. i&quot; for the <em>i</em>-th column.</p><p>The <code>header</code> can be a <code>Vector</code> or a <code>Matrix</code>. If it is a <code>Matrix</code>, then each row will be a header line. The first line is called <em>header</em> and the others are called <em>sub-headers</em> .</p><pre><code class="language-julia-repl">julia&gt; data = [1 2 3; 4 5 6];

julia&gt; pretty_table(data, [&quot;Column 1&quot;, &quot;Column 2&quot;, &quot;Column 3&quot;])
┌──────────┬──────────┬──────────┐
│ Column 1 │ Column 2 │ Column 3 │
├──────────┼──────────┼──────────┤
│        1 │        2 │        3 │
│        4 │        5 │        6 │
└──────────┴──────────┴──────────┘

julia&gt; pretty_table(data, [&quot;Column 1&quot; &quot;Column 2&quot; &quot;Column 3&quot;; &quot;A&quot; &quot;B&quot; &quot;C&quot;])
┌──────────┬──────────┬──────────┐
│ Column 1 │ Column 2 │ Column 3 │
│        A │        B │        C │
├──────────┼──────────┼──────────┤
│        1 │        2 │        3 │
│        4 │        5 │        6 │
└──────────┴──────────┴──────────┘</code></pre><pre><code class="language-julia">function pretty_table([io,] data::AbstractVecOrMat{T}, tf::PrettyTableFormat = unicode; ...) where T</code></pre><p>Print to <code>io</code> the vector or matrix <code>data</code> using the format <code>tf</code> (see <code>PrettyTableFormat</code>). If <code>io</code> is omitted, then it defaults to <code>stdout</code>. The header will be automatically filled with &quot;Col. i&quot; for the <em>i</em>-th column.</p><pre><code class="language-julia-repl">julia&gt; data = Any[1 2 3; true false true];

julia&gt; pretty_table(data)
┌────────┬────────┬────────┐
│ Col. 1 │ Col. 2 │ Col. 3 │
├────────┼────────┼────────┤
│      1 │      2 │      3 │
│   true │  false │   true │
└────────┴────────┴────────┘</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If <code>data</code> is a vector, then the <code>header</code> <strong>must</strong> be a vector. In this case, the first element is considered the header and the others are the sub-headers.</p></div></div><pre><code class="language-julia">function pretty_table([io::IO,] dict::Dict{K,V}, tf::PrettyTableFormat = unicode; sortkeys = true, ...) where {K,V}</code></pre><p>Print to <code>io</code> the dictionary <code>dict</code> in a matrix form (one column for the keys and other for the values), using the format <code>tf</code> (see <code>PrettyTableFormat</code>). If <code>io</code> is omitted, then it defaults to <code>stdout</code>.</p><p>In this case, the keyword <code>sortkeys</code> can be used to select whether or not the user wants to print the dictionary with the keys sorted. If it is <code>false</code>, then the elements will be printed on the same order returned by the functions <code>keys</code> and <code>values</code>. Notice that this assumes that the keys are sortable, if they are not, then an error will be thrown.</p><pre><code class="language-julia">julia&gt; dict = Dict(1 =&gt; &quot;Jan&quot;, 2 =&gt; &quot;Feb&quot;, 3 =&gt; &quot;Mar&quot;, 4 =&gt; &quot;Apr&quot;, 5 =&gt; &quot;May&quot;, 6 =&gt; &quot;Jun&quot;);

julia&gt; pretty_table(dict)
┌───────┬────────┐
│  Keys │ Values │
│ Int64 │ String │
├───────┼────────┤
│     4 │    Apr │
│     2 │    Feb │
│     3 │    Mar │
│     5 │    May │
│     6 │    Jun │
│     1 │    Jan │
└───────┴────────┘

julia&gt; pretty_table(dict, sortkeys = true)
┌───────┬────────┐
│  Keys │ Values │
│ Int64 │ String │
├───────┼────────┤
│     1 │    Jan │
│     2 │    Feb │
│     3 │    Mar │
│     4 │    Apr │
│     5 │    May │
│     6 │    Jun │
└───────┴────────┘
</code></pre><pre><code class="language-julia">function pretty_table([io,] table, tf::PrettyTableFormat = unicode; ...)</code></pre><p>Print to <code>io</code> the table <code>table</code> using the format <code>tf</code> (see <a href="../formats/#Formats-1">Formats</a>).  In this case, <code>table</code> must comply with the API of <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a>. If <code>io</code> is omitted, then it defaults to <code>stdout</code>.</p><p>In all cases, the following keywords are available:</p><ul><li><code>border_crayon</code>: Crayon to print the border.</li><li><code>header_crayon</code>: Crayon to print the header.</li><li><code>subheaders_crayon</code>: Crayon to print sub-headers.</li><li><code>rownum_header_crayon</code>: Crayon for the header of the column with the row                         numbers.</li><li><code>text_crayon</code>: Crayon to print default text.</li><li><code>alignment</code>: Select the alignment of the columns (see the section              <a href="../alignment/#Alignment-1">Alignment</a>).</li><li><code>crop</code>: Select the printing behavior when the data is bigger than the         available screen size (see <code>screen_size</code>). It can be <code>:both</code> to crop         on vertical and horizontal direction, <code>:horizontal</code> to crop only on         horizontal direction, <code>:vertical</code> to crop only on vertical direction,         or <code>:none</code> to do not crop the data at all.</li><li><code>filters_row</code>: Filters for the rows (see the section <a href="../filters/#Filters-1">Filters</a>).</li><li><code>filters_col</code>: Filters for the columns (see the section <a href="../filters/#Filters-1">Filters</a>).</li><li><code>formatter</code>: See the section <a href="../formatter/#Formatter-1">Formatter</a>.</li><li><code>highlighters</code>: A tuple with a list of highlighters (see the section                 <a href="../highlighters/#Highlighters-1">Highlighters</a>).</li><li><code>hlines</code>: A vector of <code>Int</code> indicating row numbers in which an additional           horizontal line should be drawn after the row. Notice that numbers           lower than 1 and equal or higher than the number of rows will be           neglected.</li><li><code>linebreaks</code>: If <code>true</code>, then <code>\n</code> will break the line inside the cells.               (<strong>Default</strong> = <code>false</code>)</li><li><code>noheader</code>: If <code>true</code>, then the header will not be printed. Notice that all             keywords and parameters related to the header and sub-headers will             be ignored. (<strong>Default</strong> = <code>false</code>)</li><li><code>nosubheader</code>: If <code>true</code>, then the sub-header will not be printed, <em>i.e.</em> the                header will contain only one line. Notice that this option has                no effect if <code>noheader = true</code>. (<strong>Default</strong> = <code>false</code>)</li><li><code>same_column_size</code>: If <code>true</code>, then all the columns will have the same size.                     (<strong>Default</strong> = <code>false</code>)</li><li><code>screen_size</code>: A tuple of two integers that defines the screen size (num. of                rows, num. of columns) that is available to print the table. It                is used to crop the data depending on the value of the keyword                <code>crop</code>. If it is <code>nothing</code>, then the size will be obtained                automatically. Notice that if a dimension is not positive, then                it will be treated as unlimited. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>show_row_number</code>: If <code>true</code>, then a new column will be printed showing the                    row number. (<strong>Default</strong> = <code>false</code>)</li></ul><p>The keywords <code>header_crayon</code> and <code>subheaders_crayon</code> can be a <code>Crayon</code> or a <code>Vector{Crayon}</code>. In the first case, the <code>Crayon</code> will be applied to all the elements. In the second, each element can have its own crayon, but the length of the vector must be equal to the number of columns in the data.</p><h2><a class="nav-anchor" id="Crayons-1" href="#Crayons-1">Crayons</a></h2><p>A <code>Crayon</code> is an object that handles a style for text printed on terminals. It is defined in the package <a href="https://github.com/KristofferC/Crayons.jl">Crayons.jl</a>. There are many options available to customize the style, such as foreground color, background color, bold text, etc.</p><p>A <code>Crayon</code> can be created in two different ways:</p><pre><code class="language-julia-repl">julia&gt; Crayon(foreground = :blue, background = :black, bold = :true)

julia&gt; crayon&quot;blue bg:black bold&quot;</code></pre><p>For more information, see the <a href="https://github.com/KristofferC/Crayons.jl/blob/master/README.md">Crayon.jl documentation</a>.</p><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>The Crayon.jl package is re-exported by PrettyTables.jl. Hence, you do not need <code>using Crayons</code> to create a <code>Crayon</code>.</p></div></div><h2><a class="nav-anchor" id="Cropping-1" href="#Cropping-1">Cropping</a></h2><p>By default, the data will be cropped to fit the screen. This behavior can be changed by using the keyword <code>crop</code>.</p><pre><code class="language-julia-repl">julia&gt; data = Any[1    false      1.0     0x01 ;
                  2     true      2.0     0x02 ;
                  3    false      3.0     0x03 ;
                  4     true      4.0     0x04 ;
                  5    false      5.0     0x05 ;
                  6     true      6.0     0x06 ;];

julia&gt; pretty_table(data, screen_size = (10,30))
┌────────┬────────┬────────┬ ⋯
│ Col. 1 │ Col. 2 │ Col. 3 │ ⋯
├────────┼────────┼────────┼ ⋯
│      1 │  false │    1.0 │ ⋯
│      2 │   true │    2.0 │ ⋯
│   ⋮    │   ⋮    │   ⋮    │ ⋯
└────────┴────────┴────────┴ ⋯

julia&gt; pretty_table(data, screen_size = (10,30), crop = :none)
┌────────┬────────┬────────┬────────┐
│ Col. 1 │ Col. 2 │ Col. 3 │ Col. 4 │
├────────┼────────┼────────┼────────┤
│      1 │  false │    1.0 │      1 │
│      2 │   true │    2.0 │      2 │
│      3 │  false │    3.0 │      3 │
│      4 │   true │    4.0 │      4 │
│      5 │  false │    5.0 │      5 │
│      6 │   true │    6.0 │      6 │
└────────┴────────┴────────┴────────┘</code></pre><p>If the keyword <code>screen_size</code> is not specified (or is <code>nothing</code>), then the screen size will be obtained automatically. For files, <code>screen_size = (-1,-1)</code>, meaning that no limit exits in both vertical and horizontal direction.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>In vertical cropping, the header and the first table row is <strong>always</strong> printed.    </p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The highlighters will work even in partially printed data.</p></div></div><h2><a class="nav-anchor" id="Helpers-1" href="#Helpers-1">Helpers</a></h2><p>The macro <code>@pt</code> was created to make it easier to pretty print tables to <code>stdout</code>. Its signature is:</p><pre><code class="language-julia">macro pt(expr...)</code></pre><p>where the expression list <code>expr</code> must be:</p><pre><code class="language-none">[&lt;Set of configurations&gt; table]*</code></pre><p>in which the set of configurations are expressions like <code>key = value</code>. The keys can be:</p><ul><li><code>header</code>: Select a header for the table.</li><li><code>tf</code>: Select a table format.</li><li>Any other possible keyword that can be used in the function <code>pretty_table</code>.</li></ul><p>Notice that multiple tables can be printed. Furthermore, the configurations persist for multiple printing <strong>except for the header</strong>. Hence, for example:</p><pre><code class="language-julia">@pt header = header1 highlighters = hl1 formatter = ft1 table1 highlighters = hl2 table2</code></pre><p>will print <code>table1</code> using the header <code>header1</code> and the configuration <code>highlighters = hl1 formatter = ft1</code> and will print <code>table2</code> without header and using <code>highlighters = hl2 formatter = ft1</code>.</p><pre><code class="language-julia-repl">julia&gt; data = [1 2 3; 4 5 6];

julia&gt; @pt data
┌──────────┬──────────┬──────────┐
│ Column 1 │ Column 2 │ Column 3 │
├──────────┼──────────┼──────────┤
│        1 │        2 │        3 │
│        4 │        5 │        6 │
└──────────┴──────────┴──────────┘

julia&gt; @pt header = [&quot;Column 1&quot;, &quot;Column 2&quot;, &quot;Column 3&quot;] data header = [&quot;Column 1&quot; &quot;Column 2&quot; &quot;Column 3&quot;; &quot;A&quot; &quot;B&quot; &quot;C&quot;] data
┌──────────┬──────────┬──────────┐
│ Column 1 │ Column 2 │ Column 3 │
├──────────┼──────────┼──────────┤
│        1 │        2 │        3 │
│        4 │        5 │        6 │
└──────────┴──────────┴──────────┘
┌──────────┬──────────┬──────────┐
│ Column 1 │ Column 2 │ Column 3 │
│        A │        B │        C │
├──────────┼──────────┼──────────┤
│        1 │        2 │        3 │
│        4 │        5 │        6 │
└──────────┴──────────┴──────────┘</code></pre><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>When more than one table is passed to this macro, then multiple calls to <code>pretty_table</code> will occur. Hence, the cropping algorithm will behave exactly the same as printing the tables separately.</p></div></div><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../alignment/"><span class="direction">Next</span><span class="title">Alignment</span></a></footer></article></body></html>
