<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Pretty Tables</title><link rel="canonical" href="https://ronisbr.github.io/PrettyTables.jl/stable/lib/library/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Pretty Tables logo"/></a><div class="docs-package-name"><span class="docs-autofit">Pretty Tables</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../man/usage/">Usage</a></li><li><span class="tocitem">Back-ends</span><ul><li><a class="tocitem" href="../../man/text_backend/">Text</a></li><li><a class="tocitem" href="../../man/html_backend/">HTML</a></li><li><a class="tocitem" href="../../man/latex_backend/">LaTeX</a></li></ul></li><li><a class="tocitem" href="../../man/alignment/">Alignment</a></li><li><a class="tocitem" href="../../man/filters/">Filters</a></li><li><a class="tocitem" href="../../man/formatters/">Formatters</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../man/text_examples/">Text back-end</a></li><li><a class="tocitem" href="../../man/html_examples/">HTML back-end</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ronisbr/PrettyTables.jl/blob/master/docs/src/lib/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documentation for <code>PrettyTables.jl</code>.</p><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.ColumnTable" href="#PrettyTables.ColumnTable"><code>PrettyTables.ColumnTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ColumnTable</code></pre><p>This structure helps to access elements that comply with the column access specification of Tables.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/types.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.Display" href="#PrettyTables.Display"><code>PrettyTables.Display</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Display</code></pre><p>Store the information of the display and the current cursor position. Notice that this is not the real cursor position with respect to the display, but with respect to the point in which the table is printed.</p><p><strong>Fields</strong></p><ul><li><code>size</code>: Display size.</li><li><code>row</code>: Current row.</li><li><code>col</code>: Current column.</li><li><code>has_color</code>: Indicates if the display has color support.</li><li><code>cont_char</code>: The character that indicates the line is cropped.</li><li><code>cont_space_char</code>: Space character to be printed before <code>cont_char</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.HTMLDecoration" href="#PrettyTables.HTMLDecoration"><code>PrettyTables.HTMLDecoration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HTMLDecoration</code></pre><p>Structure that defines parameters to decorate a table cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.HTMLHighlighter" href="#PrettyTables.HTMLHighlighter"><code>PrettyTables.HTMLHighlighter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HTMLHighlighter</code></pre><p>Defines the default highlighter of a table when using the html backend.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: Function with the signature <code>f(data,i,j)</code> in which should return <code>true</code>      if the element <code>(i,j)</code> in <code>data</code> must be highlighter, or <code>false</code>      otherwise.</li><li><code>fd</code>: Function with the signature <code>f(h,data,i,j)</code> in which <code>h</code> is the       highlighter. This function must return the <code>HTMLDecoration</code> to be       applied to the cell that must be highlighted.</li><li><code>decoration</code>: The <code>HTMLDecoration</code> to be applied to the highlighted cell if               the default <code>fd</code> is used.</li></ul><p><strong>Remarks</strong></p><p>This structure can be constructed using two helpers:</p><pre><code class="language-none">HTMLHighlighter(f::Function, decoration::HTMLDecoration)

HTMLHighlighter(f::Function, fd::Function)</code></pre><p>The first will apply a fixed decoration to the highlighted cell specified in <code>decoration</code> whereas the second let the user select the desired decoration by specifying the function <code>fd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.HTMLTableFormat" href="#PrettyTables.HTMLTableFormat"><code>PrettyTables.HTMLTableFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HTMLTableFormat</code></pre><p>Format that will be used to print the HTML table. All parameters are strings compatible with the corresponding HTML property.</p><p><strong>Fields</strong></p><ul><li><code>css</code>: CSS to be injected at the end of the <code>&lt;style&gt;</code> section.</li><li><code>table_width</code>: Table width.</li></ul><p><strong>Remarks</strong></p><p>Besides the usual HTML tags related to the tables (<code>table</code>, <code>td,</code>th<code>,</code>tr<code>, etc.), there are three important classes that can be used to format tables using the variable</code>css`.</p><ul><li><code>header</code>: This is the class of the header (first line).</li><li><code>subheader</code>: This is the class of the sub-headers (all the rest of the lines              in the header section).</li><li><code>headerLastRow</code>: The last row of the header section has additionally this                  class.</li><li><code>rowNumber</code>: All the cells related to the row number have this class. Thus,              the row number header can be styled using <code>th.rowNumber</code> and the              row numbers cells can be styled using <code>td.rowNumber</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.Highlighter" href="#PrettyTables.Highlighter"><code>PrettyTables.Highlighter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Highlighter</code></pre><p>Defines the default highlighter of a table when using the text backend.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: Function with the signature <code>f(data,i,j)</code> in which should return <code>true</code>      if the element <code>(i,j)</code> in <code>data</code> must be highlighter, or <code>false</code>      otherwise.</li><li><code>fd</code>: Function with the signature <code>f(h,data,i,j)</code> in which <code>h</code> is the       highlighter. This function must return the <code>Crayon</code> to be applied to the       cell that must be highlighted.</li><li><code>crayon</code>: The <code>Crayon</code> to be applied to the highlighted cell if the default           <code>fd</code> is used.</li></ul><p><strong>Remarks</strong></p><p>This structure can be constructed using three helpers:</p><pre><code class="language-none">Highlighter(f::Function; kwargs...)</code></pre><p>where it will construct a <code>Crayon</code> using the keywords in <code>kwargs</code> and apply it to the highlighted cell,</p><pre><code class="language-none">Highlighter(f::Function, crayon::Crayon)</code></pre><p>where it will apply the <code>crayon</code> to the highlighted cell, and</p><pre><code class="language-none">Highlighter(f::Function, fd::Function)</code></pre><p>where it will apply the <code>Crayon</code> returned by the function <code>fd</code> to the highlighted cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.LatexHighlighter" href="#PrettyTables.LatexHighlighter"><code>PrettyTables.LatexHighlighter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LatexHighlighter</code></pre><p>Defines the default highlighter of a table when using the LaTeX backend.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: Function with the signature <code>f(data,i,j)</code> in which should return <code>true</code>      if the element <code>(i,j)</code> in <code>data</code> must be highlighted, or <code>false</code>      otherwise.</li><li><code>fd</code>: A function with the signature <code>f(data,i,j,str)::String</code> in which       <code>data</code> is the matrix, <code>(i,j)</code> is the element position in the table, and       <code>str</code> is the data converted to string. This function must return a       string that will be placed in the cell.</li></ul><p><strong>Remarks</strong></p><p>This structure can be constructed using two helpers:</p><pre><code class="language-none">LatexHighlighter(f::Function, envs::Union{String,Vector{String}})

LatexHighlighter(f::Function, fd::Function)</code></pre><p>The first will apply recursively all the LaTeX environments in <code>envs</code> to the highlighted text whereas the second let the user select the desired decoration by specifying the function <code>fd</code>.</p><p>Thus, for example:</p><pre><code class="language-none">LatexHighlighter((data,i,j)-&gt;true, [&quot;textbf&quot;, &quot;small&quot;])</code></pre><p>will wrap all the cells in the table in the following environment:</p><pre><code class="language-none">\textbf{\small{&lt;Cell text&gt;}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.LatexTableFormat" href="#PrettyTables.LatexTableFormat"><code>PrettyTables.LatexTableFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LatexTableFormat</code></pre><p>This structure defines the format of the LaTeX table.</p><p><strong>Fields</strong></p><ul><li><code>top_line</code>: Top line of the table.</li><li><code>header_line</code>: Line that separate the header from the table body.</li><li><code>mid_line</code>: Line printed in the middle of the table.</li><li><code>bottom_line</code>: Bottom line of the table.</li><li><code>left_vline</code>: Left vertical line of the table.</li><li><code>mid_vline</code>: Vertical line in the middle of the table.</li><li><code>right_vline</code>: Right vertical line of the table.</li><li><code>header_envs</code>: LaTeX environments that will be used in each header cell.</li><li><code>subheader_envs</code>: LaTeX environments that will be used in each sub-header                   cell.</li><li><code>hlines</code>: Horizontal lines that must be drawn by default.</li><li><code>vlines</code>: Vertical lines that must be drawn by default.</li><li><code>table_type</code>: Select the type of table that should be used for this format.</li><li><code>wrap_table</code>: Select if the table must be wrapped inside the environment               defined by <code>wrap_table_environment</code>.</li><li><code>wrap_table_environment</code>: Environment in which the table will be wrapped if                           <code>wrap_table</code> is true.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.PrettyTablesConf" href="#PrettyTables.PrettyTablesConf"><code>PrettyTables.PrettyTablesConf</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PrettyTablesConf</code></pre><p>Type of the object that holds a pre-defined set of configurations for PrettyTables.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/types.jl#L75-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.PrintInfo" href="#PrettyTables.PrintInfo"><code>PrettyTables.PrintInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PrintInfo{Td,Th,Trn}</code></pre><p>This structure stores the information required so that the backends can print the tables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/types.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.RowTable" href="#PrettyTables.RowTable"><code>PrettyTables.RowTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct RowTable</code></pre><p>This structure helps to access elements that comply with the row access specification of Tables.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/types.jl#L25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.TextFormat" href="#PrettyTables.TextFormat"><code>PrettyTables.TextFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TextFormat</code></pre><p><strong>Fields</strong></p><ul><li><code>up_right_corner</code>: Character in the up right corner.</li><li><code>up_left_corner</code>: Character in the up left corner.</li><li><code>bottom_left_corner</code>: Character in the bottom left corner.</li><li><code>bottom_right_corner</code>: Character in the bottom right corner.</li><li><code>up_intersection</code>: Character in the intersection of lines in the up part.</li><li><code>left_intersection</code>: Character in the intersection of lines in the left part.</li><li><code>right_intersection</code>: Character in the intersection of lines in the right                       part.</li><li><code>middle_intersection</code>: Character in the intersection of lines in the middle of                        the table.</li><li><code>bottom_intersection</code>: Character in the intersection of the lines in the                        bottom part.</li><li><code>column</code>: Character in a vertical line inside the table.</li><li><code>left_border</code>: Character used as the left border.</li><li><code>right_border</code>: Character used as the right border.</li><li><code>row</code>: Character in a horizontal line inside the table.</li><li><code>hlines</code>: Horizontal lines that must be drawn by default.</li><li><code>vlines</code>: Vertical lines that must be drawn by default.</li></ul><p><strong>Pre-defined formats</strong></p><p>The following pre-defined formats are available: <code>unicode</code> (<strong>default</strong>), <code>mysql</code>, <code>compact</code>, <code>markdown</code>, <code>simple</code>, <code>ascii_rounded</code>, and <code>ascii_dots</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._aprint" href="#PrettyTables._aprint"><code>PrettyTables._aprint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_aprint(buf, [v,] indentation = 0, nspace = 2)</code></pre><p>Print the variable <code>v</code> to the buffer <code>buf</code> at the indentation level <code>indentation</code>. Each level has <code>nspaces</code> spaces.</p><p>If <code>v</code> is not present, then only the indentation spaces will be printed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/misc.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._aprintln" href="#PrettyTables._aprintln"><code>PrettyTables._aprintln</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_aprintln(buf, [v,] indentation = 0, nspaces = 2)</code></pre><p>Same as <code>_aprint</code>, but a new line will be added at the end.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/misc.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._conf_to_nt-Tuple{PrettyTablesConf}" href="#PrettyTables._conf_to_nt-Tuple{PrettyTablesConf}"><code>PrettyTables._conf_to_nt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_conf_to_nt(conf::PrettyTablesConf)</code></pre><p>Convert the configuration object <code>conf</code> to a named tuple so that it can be passed to <code>pretty_table</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/configuration.jl#L87-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._crop_str" href="#PrettyTables._crop_str"><code>PrettyTables._crop_str</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_crop_str(str, crop_size, lstr = -1)</code></pre><p>Return a cropped string of <code>str</code> with size <code>crop_size</code>. Notice that if the last character before the crop does not fit due to its width, then blank spaces are added.</p><p>The size of the string can be passed to <code>lstr</code> to save computational burden. If <code>lstr = -1</code>, then the string length will be computed inside the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/string.jl#L10-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._draw_continuation_row-Tuple{PrettyTables.Display,IO,TextFormat,Crayon,Crayon,Array{Int64,1},Array{Int64,1},Symbol}" href="#PrettyTables._draw_continuation_row-Tuple{PrettyTables.Display,IO,TextFormat,Crayon,Crayon,Array{Int64,1},Array{Int64,1},Symbol}"><code>PrettyTables._draw_continuation_row</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_draw_continuation_row(display::Display, io::IO, tf::TextFormat, text_crayon::Crayon, border_crayon::Crayon, cols_width::Vector{Int}, vlines::Vector{Int}, alignment::Symbol)</code></pre><p>Draw the continuation row when the table has filled the vertical space available. This function prints in each column the character <code>⋮</code> with the alignment in <code>alignment</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/display.jl#L10-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._draw_line!-Tuple{PrettyTables.Display,IO,Char,Char,Char,Char,Crayon,Array{Int64,1},Array{Int64,1}}" href="#PrettyTables._draw_line!-Tuple{PrettyTables.Display,IO,Char,Char,Char,Char,Crayon,Array{Int64,1},Array{Int64,1}}"><code>PrettyTables._draw_line!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_draw_line!(display::Display, io::IO, left::Char, intersection::Char, right::Char, row::Char, border_crayon::Crayon, cols_width::Vector{Int}, vlines::Vector{Int})</code></pre><p>Draw a vertical line in internal line buffer of <code>display</code> and then flush to the io <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/display.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._eol-Tuple{PrettyTables.Display}" href="#PrettyTables._eol-Tuple{PrettyTables.Display}"><code>PrettyTables._eol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_eol(display::Display)</code></pre><p>Return <code>true</code> if the cursor is at the end of line or <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/display.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._get_composed_ansi_format-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractString" href="#PrettyTables._get_composed_ansi_format-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractString"><code>PrettyTables._get_composed_ansi_format</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_get_composed_ansi_format(ansi::Vector{T}) where T&lt;:AbstractString</code></pre><p>Given a vector with a set of ANSI escape sequences, return a composed escape sequence that leads to the same formatting.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function only works with the minimal set used by <code>Markdown</code> in <code>stdlib</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/string.jl#L262-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._nl!-Tuple{PrettyTables.Display,IO}" href="#PrettyTables._nl!-Tuple{PrettyTables.Display,IO}"><code>PrettyTables._nl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_nl!(display::Display, io::IO)</code></pre><p>Flush the internal line buffer of <code>display</code> into <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/display.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._p!" href="#PrettyTables._p!"><code>PrettyTables._p!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_p!(display::Display, crayon::Crayon, str::Char, final_line_print::Bool = false, lstr::Int = -1)
_p!(display::Display, crayon::Crayon, str::String, final_line_print::Bool = false, lstr::Int = -1)</code></pre><p>Print <code>str</code> into the internal line buffer of <code>display</code> using the Crayon <code>crayon</code> with the display information in <code>display</code>. The parameter <code>final_line_print</code> must be set to <code>true</code> if this is the last string that will be printed in the line. This is necessary for the algorithm to select whether or not to include the continuation character.</p><p>The size of the string can be passed to <code>lstr</code> to save computational burden. If <code>lstr = -1</code>, then the string length will be computed inside the function.</p><p>The line buffer can be flushed to an <code>io</code> using the function <code>_nl!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/display.jl#L115-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._parse_cell_html-Tuple{Any}" href="#PrettyTables._parse_cell_html-Tuple{Any}"><code>PrettyTables._parse_cell_html</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_parse_cell_html(cell::T; kwargs...)</code></pre><p>Parse the table cell <code>cell</code> of type <code>T</code>. This function must return a string that will be printed to the IO.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/html/cell_parse.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._parse_cell_latex-Tuple{Any}" href="#PrettyTables._parse_cell_latex-Tuple{Any}"><code>PrettyTables._parse_cell_latex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_parse_cell_latex(cell::T; kwargs...)</code></pre><p>Parse the table cell <code>cell</code> of type <code>T</code>. This function must return a string that will be printed to the IO.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/latex/cell_parse.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._parse_cell_text-Tuple{Any}" href="#PrettyTables._parse_cell_text-Tuple{Any}"><code>PrettyTables._parse_cell_text</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_parse_cell_text(cell::T; kwargs...)</code></pre><p>Parse the table cell <code>cell</code> of type <code>T</code>. This function must return:</p><ul><li>A vector of <code>String</code> with the parsed cell text, one component per line.</li><li>A vector with the length of each parsed line.</li><li>The necessary width for the cell.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/cell_parse.jl#L10-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._pc!" href="#PrettyTables._pc!"><code>PrettyTables._pc!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_pc!(cond::Bool, display::Display, io::IO, crayon::Crayon, str_true::Union{Char,String}, str_false::Union{Char,String}, final_line_print::Bool = false, lstr_true::Int = -1, lstr_false::Int = -1)</code></pre><p>If <code>cond == true</code> then print <code>str_true</code>. Otherwise, print <code>str_false</code>. Those strings will be printed into the internal line buffer of <code>display</code> using the Crayon <code>crayon</code> with the display information in <code>display</code>. The parameter <code>final_line_print</code> must be set to <code>true</code> if this is the last string that will be printed in the line. This is necessary for the algorithm to select whether or not to include the continuation character.</p><p>The size of the strings can be passed to <code>lstr_true</code> and <code>lstr_false</code> to save computational burden. If they are <code>-1</code>, then the string lengths will be computed inside the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/display.jl#L229-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._process_cell_text-Tuple{Any,Int64,Int64,Bool,String,Int64,Int64,Crayon,Symbol,Tuple}" href="#PrettyTables._process_cell_text-Tuple{Any,Int64,Int64,Bool,String,Int64,Int64,Crayon,Symbol,Tuple}"><code>PrettyTables._process_cell_text</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_process_cell_text(data::Any, i::Int, j::Int, data_cell::Bool, data_str::String, data_len::Int, col_width::Int, crayon::Crayon, alignment::Symbol, highlighters::Tuple)</code></pre><p>Process the cell by applying the right alignment and also verifying the highlighters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/cell_parse.jl#L108-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._process_hlines-Tuple{Symbol,AbstractArray{T,1} where T,Int64,Bool}" href="#PrettyTables._process_hlines-Tuple{Symbol,AbstractArray{T,1} where T,Int64,Bool}"><code>PrettyTables._process_hlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_process_hlines(hlines::Union{Symbol,AbstractVector}, body_hlines::AbstractVector, num_printed_rows::Int, noheader::Bool)</code></pre><p>Process the horizontal lines in <code>hlines</code> and <code>body_hlines</code> considering the number of printed rows <code>num_printed_rows</code> and if the header is present (<code>noheader</code>).</p><p>It returns a vector of <code>Int</code> stating where the horizontal lines must be drawn.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/misc.jl#L91-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._process_vlines-Tuple{Symbol,Int64}" href="#PrettyTables._process_vlines-Tuple{Symbol,Int64}"><code>PrettyTables._process_vlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_process_vlines(vlines::AbstractVector, num_printed_cols::Int)</code></pre><p>Process the vertical lines <code>vlines</code> considerering the number of printed columns <code>num_printed_cols</code>.</p><p>It returns a vector of <code>Int</code> stating where the vertical lines must be drawn.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/misc.jl#L140-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._reapply_ansi_format!-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractString" href="#PrettyTables._reapply_ansi_format!-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractString"><code>PrettyTables._reapply_ansi_format!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_reapply_ansi_format!(lines::Vector{T}) where T&lt;:AbstractString</code></pre><p>For each line in <code>lines</code>, reapply the ANSI format left by the previous line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/string.jl#L316-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._render_text-Tuple{Val{:print},Any}" href="#PrettyTables._render_text-Tuple{Val{:print},Any}"><code>PrettyTables._render_text</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_render_text(T, v; compact_printing::Bool = true, isstring::Bool = false, linebreaks::Bool = false)</code></pre><p>Render the value <code>v</code> to strings using the rendered <code>T</code> to be displayed in the text back-end.</p><p><code>T</code> can be:</p><ul><li><code>Val(:print)</code>: the function <code>print</code> will be used.</li><li><code>Val(:show)</code>: the function <code>show</code> will be used.</li></ul><p>This function must return a vector of strings in which each element is a line inside the rendered cell.</p><p>If <code>linebreaks</code> is <code>true</code>, then the rendered should split the created string into multiple tokens.</p><p>In case <code>show</code> is used, if <code>isstring</code> is <code>false</code>, then it means that the original data is not a string even if <code>v</code> is a string. Hence, the surrounding quotes added by <code>show</code> will be removed. This is required to correctly handle formatters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/string.jl#L68-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._str_aligned" href="#PrettyTables._str_aligned"><code>PrettyTables._str_aligned</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_str_aligned(data::String, alignment::Symbol, field_size::Integer, lstr::Integer = -1)</code></pre><p>This function returns the string <code>data</code> with alignment <code>alignment</code> in a field with size <code>field_size</code>. <code>alignment</code> can be <code>:l</code> or <code>:L</code> for left alignment, <code>:c</code> or <code>:C</code> for center alignment, or <code>:r</code> or <code>:R</code> for right alignment. It defaults to <code>:r</code> if <code>alignment</code> is any other symbol.</p><p>This function also returns the new size of the aligned string.</p><p>If the string is larger than <code>field_size</code>, then it will be cropped and <code>⋯</code> will be added as the last character.</p><p>The size of the string can be passed to <code>lstr</code> to save computational burden. If <code>lstr = -1</code>, then the string length will be computed inside the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/string.jl#L143-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._str_autowrap" href="#PrettyTables._str_autowrap"><code>PrettyTables._str_autowrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_str_autowrap(tokens_raw::Vector{String}, width::Int = 0)</code></pre><p>Autowrap the tokens in <code>tokens_raw</code> considering a field width of <code>width</code>. It returns a new vector with the new wrapped tokens.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/string.jl#L189-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables._str_escaped-Tuple{AbstractString}" href="#PrettyTables._str_escaped-Tuple{AbstractString}"><code>PrettyTables._str_escaped</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_str_escaped(str::AbstractString)</code></pre><p>Return the escaped string representation of <code>str</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/misc.jl#L180-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.clear_pt_conf!-Tuple{PrettyTablesConf}" href="#PrettyTables.clear_pt_conf!-Tuple{PrettyTablesConf}"><code>PrettyTables.clear_pt_conf!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear_pt_conf!(conf::PrettyTablesConf)</code></pre><p>Clear all configurations in <code>conf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/configuration.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.compact_type_str-Tuple{Any}" href="#PrettyTables.compact_type_str-Tuple{Any}"><code>PrettyTables.compact_type_str</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compact_type_str(T)</code></pre><p>Return a string with a compact representation of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/misc.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.ft_latex_sn-Tuple{Int64}" href="#PrettyTables.ft_latex_sn-Tuple{Int64}"><code>PrettyTables.ft_latex_sn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ft_latex_sn(m_digits, [columns])</code></pre><p>Format the numbers of the elements in the columns <code>columns</code> to a scientific notation using LaTeX. The number is first printed using <code>sprintf1</code> functions with the <code>g</code> modifier and then converted to the LaTeX format. The number of digits in the mantissa can be selected by the argument <code>m_digits</code>.</p><p>If <code>m_digits</code> is a <code>Vector</code>, then <code>columns</code> must be also be a <code>Vector</code> with the same number of elements. If <code>m_digits</code> is a <code>Integer</code>, and <code>columns</code> is not specified (or is empty), then the format will be applied to the entire table. Otherwise, if <code>m_digits</code> is a <code>String</code> and <code>columns</code> is a <code>Vector</code>, then the format will be applied only to the columns in <code>columns</code>.</p><p><strong>Remarks</strong></p><p>This formatter will be applied only to the cells that are of type <code>Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/predefined_formatters.jl#L113-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.ft_printf-Tuple{String}" href="#PrettyTables.ft_printf-Tuple{String}"><code>PrettyTables.ft_printf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ft_printf(ftv_str, [columns])</code></pre><p>Apply the formats <code>ftv_str</code> (see the function <code>sprintf1</code> of the package <strong>Formatting.jl</strong>) to the elements in the columns <code>columns</code>.</p><p>If <code>ftv_str</code> is a <code>Vector</code>, then <code>columns</code> must be also be a <code>Vector</code> with the same number of elements. If <code>ftv_str</code> is a <code>String</code>, and <code>columns</code> is not specified (or is empty), then the format will be applied to the entire table. Otherwise, if <code>ftv_str</code> is a <code>String</code> and <code>columns</code> is a <code>Vector</code>, then the format will be applied only to the columns in <code>columns</code>.</p><p><strong>Remarks</strong></p><p>This formatter will be applied only to the cells that are of type <code>Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/predefined_formatters.jl#L10-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.ft_round-Tuple{Int64}" href="#PrettyTables.ft_round-Tuple{Int64}"><code>PrettyTables.ft_round</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ft_round(digits, [columns])</code></pre><p>Round the elements in the columns <code>columns</code> to the number of digits in <code>digits</code>.</p><p>If <code>digits</code> is a <code>Vector</code>, then <code>columns</code> must be also be a <code>Vector</code> with the same number of elements. If <code>digits</code> is a <code>Number</code>, and <code>columns</code> is not specified (or is empty), then the rounding will be applied to the entire table. Otherwise, if <code>digits</code> is a <code>Number</code> and <code>columns</code> is a <code>Vector</code>, then the elements in the columns <code>columns</code> will be rounded to the number of digits <code>digits</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/predefined_formatters.jl#L62-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_cell-Tuple{Number,Number,Crayon}" href="#PrettyTables.hl_cell-Tuple{Number,Number,Crayon}"><code>PrettyTables.hl_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_cell(i::Number, j::Number, crayon::Crayon)</code></pre><p>Highlight the cell <code>(i,j)</code> with the crayon <code>crayon</code>.</p><pre><code class="language-none">hl_cell(cells::AbstractVector{NTuple(2,Int)}, crayon::Crayon)</code></pre><p>Highlights all the cells in <code>cells</code> with the crayon <code>crayon</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>Highlighter</code> to be used with the text backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/predefined_highlighters.jl#L11-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_cell-Tuple{Number,Number,HTMLDecoration}" href="#PrettyTables.hl_cell-Tuple{Number,Number,HTMLDecoration}"><code>PrettyTables.hl_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_cell(i::Number, j::Number, decoration::HTMLDecoration)</code></pre><p>Highlight the cell <code>(i,j)</code> with the decoration <code>decoration</code> (see <code>HTMLDecoration</code>).</p><pre><code class="language-none">hl_cell(cells::AbstractVector{NTuple(2,Int)}, decoration::HTMLDecoration)</code></pre><p>Highlights all the cells in <code>cells</code> with the decoration <code>decoration</code> (see <code>HTMLDecoration</code>).</p><p><strong>Remarks</strong></p><p>Those functions return a <code>HTMLHighlighter</code> to be used with the HTML backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/html/predefined_highlighters.jl#L11-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_col-Tuple{Number,Crayon}" href="#PrettyTables.hl_col-Tuple{Number,Crayon}"><code>PrettyTables.hl_col</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_col(i::Number, crayon::Crayon)</code></pre><p>Highlight the entire column <code>i</code> with the crayon <code>crayon</code>.</p><pre><code class="language-none">hl_col(cols::AbstractVector{Int}, crayon::Crayon)</code></pre><p>Highlights all the columns in <code>cols</code> with the crayon <code>crayon</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>Highlighter</code> to be used with the text backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/predefined_highlighters.jl#L39-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_col-Tuple{Number,HTMLDecoration}" href="#PrettyTables.hl_col-Tuple{Number,HTMLDecoration}"><code>PrettyTables.hl_col</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_col(i::Number, decoration::HTMLDecoration)</code></pre><p>Highlight the entire column <code>i</code> with the decoration <code>decoration</code>.</p><pre><code class="language-none">hl_col(cols::AbstractVector{Int}, decoration::HTMLDecoration)</code></pre><p>Highlights all the columns in <code>cols</code> with the decoration <code>decoration</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>HTMLHighlighter</code> to be used with the HTML backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/html/predefined_highlighters.jl#L41-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_geq-Tuple{Number,HTMLDecoration}" href="#PrettyTables.hl_geq-Tuple{Number,HTMLDecoration}"><code>PrettyTables.hl_geq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_geq(n::Number, decoration::HTMLDecoration)</code></pre><p>Highlight all elements that ≥ <code>n</code> using the decoration <code>decoration</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>HTMLHighlighter</code> to be used with the text backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/html/predefined_highlighters.jl#L160-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_geq-Tuple{Number}" href="#PrettyTables.hl_geq-Tuple{Number}"><code>PrettyTables.hl_geq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_geq(n::Number)</code></pre><p>Highlight all elements that ≥ <code>n</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>Highlighter</code> to be used with the text backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/predefined_highlighters.jl#L161-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_gt-Tuple{Number,HTMLDecoration}" href="#PrettyTables.hl_gt-Tuple{Number,HTMLDecoration}"><code>PrettyTables.hl_gt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_gt(n::Number, decoration::HTMLDecoration)</code></pre><p>Highlight all elements that &gt; <code>n</code> using the decoration <code>decoration</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>HTMLHighlighter</code> to be used with the text backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/html/predefined_highlighters.jl#L139-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_gt-Tuple{Number}" href="#PrettyTables.hl_gt-Tuple{Number}"><code>PrettyTables.hl_gt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_gt(n::Number)</code></pre><p>Highlight all elements that &gt; <code>n</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>Highlighter</code> to be used with the text backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/predefined_highlighters.jl#L139-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_leq-Tuple{Number,HTMLDecoration}" href="#PrettyTables.hl_leq-Tuple{Number,HTMLDecoration}"><code>PrettyTables.hl_leq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_leq(n::Number, decoration::HTMLDecoration)</code></pre><p>Highlight all elements that ≤ <code>n</code> using the decoration <code>decoration</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>HTMLHighlighter</code> to be used with the text backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/html/predefined_highlighters.jl#L118-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_leq-Tuple{Number}" href="#PrettyTables.hl_leq-Tuple{Number}"><code>PrettyTables.hl_leq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_leq(n::Number)</code></pre><p>Highlight all elements that ≤ <code>n</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>Highlighter</code> to be used with the text backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/predefined_highlighters.jl#L117-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_lt-Tuple{Number,HTMLDecoration}" href="#PrettyTables.hl_lt-Tuple{Number,HTMLDecoration}"><code>PrettyTables.hl_lt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_lt(n::Number, decoration::HTMLDecoration)</code></pre><p>Highlight all elements that &lt; <code>n</code> using the decoration <code>decoration</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>HTMLHighlighter</code> to be used with the text backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/html/predefined_highlighters.jl#L97-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_lt-Tuple{Number}" href="#PrettyTables.hl_lt-Tuple{Number}"><code>PrettyTables.hl_lt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_lt(n::Number)</code></pre><p>Highlight all elements that &lt; <code>n</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>Highlighter</code> to be used with the text backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/predefined_highlighters.jl#L95-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_row-Tuple{Number,Crayon}" href="#PrettyTables.hl_row-Tuple{Number,Crayon}"><code>PrettyTables.hl_row</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_row(i::Number, crayon::Crayon)</code></pre><p>Highlight the entire row <code>i</code> with the crayon <code>crayon</code>.</p><pre><code class="language-none">hl_row(rows::AbstractVector{Int}, crayon::Crayon)</code></pre><p>Highlights all the rows in <code>rows</code> with the crayon <code>crayon</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>Highlighter</code> to be used with the text backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/predefined_highlighters.jl#L67-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_row-Tuple{Number,HTMLDecoration}" href="#PrettyTables.hl_row-Tuple{Number,HTMLDecoration}"><code>PrettyTables.hl_row</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_row(i::Number, decoration::HTMLDecoration)</code></pre><p>Highlight the entire row <code>i</code> with the decoration <code>decoration</code>.</p><pre><code class="language-none">hl_row(rows::AbstractVector{Int}, decoration::HTMLDecoration)</code></pre><p>Highlights all the rows in <code>rows</code> with the decoration <code>decoration</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>HTMLHighlighter</code> to be used with the HTML backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/html/predefined_highlighters.jl#L69-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_value-Tuple{Any,HTMLDecoration}" href="#PrettyTables.hl_value-Tuple{Any,HTMLDecoration}"><code>PrettyTables.hl_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_value(v::Any, decoration::HTMLDecoration)</code></pre><p>Highlight all the values that matches <code>data[i,j] == v</code> using the decoration <code>decoration</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>HTMLHighlighter</code> to be used with the text backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/html/predefined_highlighters.jl#L181-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.hl_value-Tuple{Any}" href="#PrettyTables.hl_value-Tuple{Any}"><code>PrettyTables.hl_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hl_value(v::Any)</code></pre><p>Highlight all the values that matches <code>data[i,j] == v</code>.</p><p><strong>Remarks</strong></p><p>Those functions return a <code>Highlighter</code> to be used with the text backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/backends/text/predefined_highlighters.jl#L183-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.include_pt_in_file-Tuple{AbstractString,AbstractString,Vararg{Any,N} where N}" href="#PrettyTables.include_pt_in_file-Tuple{AbstractString,AbstractString,Vararg{Any,N} where N}"><code>PrettyTables.include_pt_in_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">include_pt_in_file(filename::AbstractString, mark::AbstractString, args...; kwargs...)</code></pre><p>Include a table in the file <code>filename</code> using the mark <code>mark</code>.</p><p>This function will print a table using the arguments <code>args</code> and keywords <code>kwargs</code> in the function <code>pretty_table</code> (<strong>the IO must not be passed to <code>args</code> here</strong>). Then, it will search inside the file <code>filename</code> for the following section:</p><pre><code class="language-none">&lt;PrettyTables mark&gt;
...
&lt;/PrettyTables&gt;</code></pre><p>and will <strong>replace everything between the marks</strong> with the printed table. If the closing tag is in a separate line, then all characters before it will be kept. This is important to add comment tags.</p><p>If the user wants to also remove the opening and ending tags, then pass the keyword <code>remove_tags = true</code>.</p><p>The keyword <code>tag_append</code> can be used to pass a string that can be used to add a text after the opening tag. This is important for HTML where the comments have openning and closing tags. Thus, if <code>tag_append = &quot; --&gt;&quot;</code>, then the following can be used to add a table into HTML files:</p><pre><code class="language-none">&lt;!-- &lt;PrettyTables mark&gt; --&gt;
...
&lt;!-- &lt;/PrettyTables&gt; --&gt;</code></pre><p>By default, this function will copy the original file to <code>filename_backup</code>. If this is not desired, then pass the keyword <code>backup_file = false</code> to the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/files.jl#L11-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.pretty_table-Tuple{Any}" href="#PrettyTables.pretty_table-Tuple{Any}"><code>PrettyTables.pretty_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pretty_table([io::IO | String,] table[, header::AbstractVecOrMat];  kwargs...)</code></pre><p>Print to <code>io</code> the table <code>table</code> with header <code>header</code>. If <code>conf</code> is omitted, then the default configuration will be used. If <code>io</code> is omitted, then it defaults to <code>stdout</code>. If <code>String</code> is passed in the place of <code>io</code>, then a <code>String</code> with the printed table will be returned by the function.</p><p>The <code>header</code> can be a <code>Vector</code> or a <code>Matrix</code>. If it is a <code>Matrix</code>, then each row will be a header line. The first line is called <em>header</em> and the others are called <em>sub-headers</em> . If <code>header</code> is empty or missing, then it will be automatically filled with &quot;Col.  i&quot; for the <em>i</em>-th column.</p><p>When printing, it will be verified if <code>table</code> complies with <strong>Tables.jl</strong> API. If it is compliant, then this interface will be used to print the table. If it is not compliant, then only the following types are supported:</p><ol><li><code>AbstractVector</code>: any vector can be printed. In this case, the <code>header</code> <strong>must</strong> be a vector, where the first element is considered the header and the others are the sub-headers.</li><li><code>AbstractMatrix</code>: any matrix can be printed.</li><li><code>Dict</code>: any <code>Dict</code> can be printed. In this case, the special keyword <code>sortkeys</code> can be used to select whether or not the user wants to print the dictionary with the keys sorted. If it is <code>false</code>, then the elements will be printed on the same order returned by the functions <code>keys</code> and <code>values</code>. Notice that this assumes that the keys are sortable, if they are not, then an error will be thrown.</li></ol><p><strong>Keywords</strong></p><ul><li><p><code>alignment</code>: Select the alignment of the columns (see the section <code>Alignment</code>).</p></li><li><p><code>backend</code>: Select which back-end will be used to print the table (see the            section <code>Backend</code>). Notice that the additional configuration in            <code>kwargs...</code> depends on the selected backend. (see the section            <code>Backend</code>).</p></li><li><p><code>cell_alignment</code>: A tuple of functions with the signature <code>f(data,i,j)</code> that                   overrides the alignment of the cell <code>(i,j)</code> to the value                   returned by <code>f</code>. It can also be a single function, when it                   is assumed that only one alignment function is required, or                   <code>nothing</code>, when no cell alignment modification will be                   performed. If the function <code>f</code> does not return a valid                   alignment symbol as shown in section <code>Alignment</code>, then it                   will be discarded. For convenience, it can also be a                   dictionary of type <code>(i,j) =&gt; a</code> that overrides the                   alignment of the cell <code>(i,j)</code> to <code>a</code>. <code>a</code> must be a symbol                   like specified in the section <code>Alignment</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If more than one alignment function is passed to <code>cell_alignment</code>, then the functions will be evaluated in the same order of the tuple. The first one that returns a valid alignment symbol for each cell is applied, and the rest is discarded.</p></div></div><p>(<strong>Default</strong> = <code>nothing</code>)</p></li><li><p><code>cell_first_line_only</code>: If <code>true</code>, then only the first line of each cell will be printed. (<strong>Default</strong> = <code>false</code>)</p></li><li><p><code>compact_printing</code>: Select if the option <code>:compact</code> will be used when printing                     the data. (<strong>Default</strong> = <code>true</code>)</p></li><li><p><code>filters_row</code>: Filters for the rows (see the section <code>Filters</code>).</p></li><li><p><code>filters_col</code>: Filters for the columns (see the section <code>Filters</code>).</p></li><li><p><code>formatters</code>: See the section <code>Formatters</code>.</p></li><li><p><code>header_alignment</code>: Select the alignment of the header columns (see the                     section <code>Alignment</code>). If the symbol that specifies the                     alignment is <code>:s</code> for a specific column, then the same                     alignment in the keyword <code>alignment</code> for that column will                     be used. (<strong>Default</strong> = <code>:s</code>)</p></li><li><p><code>header_cell_alignment</code>: This keyword has the same structure of                          <code>cell_alignment</code> but in this case it operates in the                          header. Thus, <code>(i,j)</code> will be a cell in the header                          matrix that contains the header and sub-headers. This                          means that the <code>data</code> field in the functions will be                          the same value passed in the keyword <code>header</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If more than one alignment function is passed to <code>header_cell_alignment</code>, then the functions will be evaluated in the same order of the tuple. The first one that returns a valid alignment symbol for each cell is applied, and the rest is discarded.</p></div></div><p>(<strong>Default</strong> = <code>nothing</code>)</p></li><li><p><code>renderer</code>: A symbol that indicates which function should be used to convert             an object to a string. It can be <code>:print</code> to use the function             <code>print</code> or <code>:show</code> to use the function <code>show</code>. Notice that this             selection is applicable only to the table data. Headers,             sub-headers, and row name column are always rendered with print.             (<strong>Default</strong> = <code>:print</code>)</p></li><li><p><code>row_names</code>: A vector containing the row names that will be appended to the              left of the table. If it is <code>nothing</code>, then the column with the              row names will not be shown. Notice that the size of this vector              must match the number of rows in the table.              (<strong>Default</strong> = <code>nothing</code>)</p></li><li><p><code>row_name_alignment</code>: Alignment of the column with the rows name (see the                       section <code>Alignment</code>).</p></li><li><p><code>row_name_column_title</code>: Title of the column with the row names.                          (<strong>Default</strong> = &quot;&quot;)</p></li><li><p><code>title</code>: The title of the table. If it is empty, then no title will be          printed. (<strong>Default</strong> = &quot;&quot;)</p></li><li><p><code>title_alignment</code>: Alignment of the title, which must be a symbol as explained                    in the section <code>Alignment</code>. This argument is ignored in the                    LaTeX backend. (<strong>Default</strong> = :l)</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Notice that all back-ends have the keyword <code>tf</code> to specify the table printing format. Thus, if the keyword <code>backend</code> is not present or if it is <code>nothing</code>, then the back-end will be automatically inferred from the type of the keyword <code>tf</code>. In this case, if <code>tf</code> is also not present, then it just fall-back to the text back-end.</p></div></div><p><strong>Alignment</strong></p><p>The keyword <code>alignment</code> can be a <code>Symbol</code> or a vector of <code>Symbol</code>.</p><p>If it is a symbol, we have the following behavior:</p><ul><li><code>:l</code> or <code>:L</code>: the text of all columns will be left-aligned;</li><li><code>:c</code> or <code>:C</code>: the text of all columns will be center-aligned;</li><li><code>:r</code> or <code>:R</code>: the text of all columns will be right-aligned;</li><li>Otherwise it defaults to <code>:r</code>.</li></ul><p>If it is a vector, then it must have the same number of symbols as the number of columns in <code>data</code>. The <em>i</em>-th symbol in the vector specify the alignment of the <em>i</em>-th column using the same symbols as described previously.</p><p><strong>Filters</strong></p><p>It is possible to specify filters to filter the data that will be printed. There are two types of filters: the row filters, which are specified by the keyword <code>filters_row</code>, and the column filters, which are specified by the keyword <code>filters_col</code>.</p><p>The filters are a tuple of functions that must have the following signature:</p><pre><code class="language-julia">f(data,i)::Bool</code></pre><p>in which <code>data</code> is a pointer to the matrix that is being printed and <code>i</code> is the i-th row in the case of the row filters or the i-th column in the case of column filters. If this function returns <code>true</code> for <code>i</code>, then the i-th row (in case of <code>filters_row</code>) or the i-th column (in case of <code>filters_col</code>) will be printed. Otherwise, it will be omitted.</p><p>A set of filters can be passed inside of a tuple. Notice that, in this case, <strong>all filters</strong> for a specific row or column must be return <code>true</code> so that it can be printed, <em>i.e</em> the set of filters has an <code>AND</code> logic.</p><p>If the keyword is set to <code>nothing</code>, which is the default, then no filtering will be applied to the data.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The filters do not change the row and column numbering for the others modifiers such as column width specification, formatters, and highlighters. Thus, for example, if only the 4-th row is printed, then it will also be referenced inside the formatters and highlighters as 4 instead of 1.</p></div></div><hr/><p><strong>Pretty table text back-end</strong></p><p>This back-end produces text tables. This back-end can be used by selecting <code>back-end = :text</code>.</p><p><strong>Keywords</strong></p><ul><li><p><code>border_crayon</code>: Crayon to print the border.</p></li><li><p><code>header_crayon</code>: Crayon to print the header.</p></li><li><p><code>subheader_crayon</code>: Crayon to print sub-headers.</p></li><li><p><code>rownum_header_crayon</code>: Crayon for the header of the column with the row                         numbers.</p></li><li><p><code>text_crayon</code>: Crayon to print default text.</p></li><li><p><code>alignment_anchor_fallback</code>: This keyword controls the line alignment when                              using the regex alignment anchors if a match is                              not found. If it is <code>:l</code>, then the left of the                              line will be aligned with the anchor. If it is                              <code>:c</code>, then the line center will be aligned with                              the anchor. Otherwise, the end of the line will                              be aligned with the anchor. (<strong>Default</strong> = <code>:l</code>)</p></li><li><p><code>alignment_anchor_fallback_override</code>: A <code>Dict{Int, Symbol}</code> to override the                                       behavior of <code>fallback_alignment_anchor</code>                                       for a specific column. Example:                                       <code>Dict(3 =&gt; :c)</code> changes the fallback                                       alignment anchor behavior for <code>:c</code> only                                       for the column 3.</p></li><li><p><code>alignment_anchor_regex</code>: A dictionary <code>Dict{Int, AbstractVector{Regex}}</code> with                           a set of regexes that is used to align the values in                           the columns (keys). The characters at the first                           regex match (or anchor) of each line in every cell                           of the column will be aligned. The regex match is                           searched in the same order as the regexes appear on                           the vector. The regex matching is applied after the                           cell conversion to string, which includes the                           formatters. If no match is found for a specific                           line, then the alignment of this line depends on the                           options <code>alignment_anchor_fallback</code> and                           <code>alignment_anchor_fallback_override</code>. If the key <code>0</code>                           is present, then the related regexes will be used to                           align all the columns. In this case, all the other                           keys will be neglected. Example:                           <code>Dict(2 =&gt; [r&quot;\.&quot;])</code> aligns the decimal point of                           the cells in the second column.                           (<strong>Default</strong> = <code>Dict{Int, Vector{Regex}}()</code>)</p></li><li><p><code>autowrap</code>: If <code>true</code>, then the text will be wrapped on spaces to fit the             column. Notice that this function requires <code>linebreaks = true</code> and             the column must have a fixed size (see <code>columns_width</code>).</p></li><li><p><code>body_hlines</code>: A vector of <code>Int</code> indicating row numbers in which an additional                horizontal line should be drawn after the row. Notice that                numbers lower than 1 and equal or higher than the number of                printed rows will be neglected. This vector will be appended to                the one in <code>hlines</code>, but the indices here are related to the                printed rows of the body. Thus, if <code>1</code> is added to                <code>body_hlines</code>, then a horizontal line will be drawn after the                first data row. (<strong>Default</strong> = <code>Int[]</code>)</p></li><li><p><code>body_hlines_format</code>: A tuple of 4 characters specifying the format of the                       horizontal lines that will be drawn by <code>body_hlines</code>.                       The characters must be the left intersection, the middle                       intersection, the right intersection, and the row. If it                       is <code>nothing</code>, then it will use the same format specified                       in <code>tf</code>. (<strong>Default</strong> = <code>nothing</code>)</p></li><li><p><code>columns_width</code>: A set of integers specifying the width of each column. If the                  width is equal or lower than 0, then it will be automatically                  computed to fit the large cell in the column. If it is                  a single integer, then this number will be used as the size                  of all columns. (<strong>Default</strong> = 0)</p></li><li><p><code>crop</code>: Select the printing behavior when the data is bigger than the         available display size (see <code>display_size</code>). It can be <code>:both</code> to crop         on vertical and horizontal direction, <code>:horizontal</code> to crop only on         horizontal direction, <code>:vertical</code> to crop only on vertical direction,         or <code>:none</code> to do not crop the data at all. If the <code>io</code> has         <code>:limit =&gt; true</code>, then <code>crop</code> is set to <code>:both</code> by default.         Otherwise, it is set to <code>:none</code> by default.</p></li><li><p><code>crop_num_lines_at_beginning</code>: Number of lines to be left at the beginning of                                the printing when vertically cropping the                                output. Notice that the lines required to show                                the title are automatically computed.                                (<strong>Default</strong> = 0)</p></li><li><p><code>crop_subheader</code>: If <code>true</code>, then the sub-header size will not be taken into                   account when computing the column size. Hence, the print                   algorithm can crop it to save space. This has no effect if                   the user selects a fixed column width.                   (<strong>Default</strong> = <code>false</code>)</p></li><li><p><code>continuation_row_alignment</code>: A symbol that defines the alignment of the cells                               in the continuation row. This row is printed if                               the table is vertically cropped.                               (<strong>Default</strong> = <code>:c</code>)</p></li><li><p><code>display_size</code>: A tuple of two integers that defines the display size (num. of                 rows, num. of columns) that is available to print the table.                 It is used to crop the data depending on the value of the                 keyword <code>crop</code>. Notice that if a dimension is not positive,                 then it will be treated as unlimited.                 (<strong>Default</strong> = <code>displaysize(io)</code>)</p></li><li><p><code>ellipsis_line_skip</code>: An integer defining how many lines will be skipped from                       showing the ellipsis that indicates the text was                       cropped. (<strong>Default</strong> = 0)</p></li><li><p><code>equal_columns_width</code>: If <code>true</code>, then all the columns will have the same                        width. (<strong>Default</strong> = <code>false</code>)</p></li><li><p><code>highlighters</code>: An instance of <code>Highlighter</code> or a tuple with a list of                 text highlighters (see the section <code>Text highlighters</code>).</p></li><li><p><code>hlines</code>: This variable controls where the horizontal lines will be drawn. It           can be <code>nothing</code>, <code>:all</code>, <code>:none</code> or a vector of integers.</p><ul><li>If it is <code>nothing</code>, which is the default, then the configuration will be obtained from the table format in the variable <code>tf</code> (see <code>TextFormat</code>).</li><li>If it is <code>:all</code>, then all horizontal lines will be drawn.</li><li>If it is <code>:none</code>, then no horizontal line will be drawn.</li><li>If it is a vector of integers, then the horizontal lines will be drawn only after the rows in the vector. Notice that the top line will be drawn if <code>0</code> is in <code>hlines</code>, and the header and subheaders are considered as only 1 row. Furthermore, it is important to mention that the row number in this variable is related to the <strong>printed rows</strong>. Thus, it is affected by filters, and by the option to suppress the header <code>noheader</code>. Finally, for convenience, the top and bottom lines can be drawn by adding the symbols <code>:begin</code> and <code>:end</code> to this vector, respectively, and the line after the header can be drawn by adding the symbol <code>:header</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The values of <code>body_hlines</code> will be appended to this vector. Thus, horizontal lines can be drawn even if <code>hlines</code> is <code>:none</code>.</p></div></div><p>(<strong>Default</strong> = <code>nothing</code>)</p></li><li><p><code>linebreaks</code>: If <code>true</code>, then <code>\n</code> will break the line inside the cells.               (<strong>Default</strong> = <code>false</code>)</p></li><li><p><code>maximum_columns_width</code>: A set of integers specifying the maximum width of                          each column. If the width is equal or lower than 0,                          then it will be ignored. If it is a single integer,                          then this number will be used as the maximum width                          of all columns. Notice that the parameter                          <code>columns_width</code> has precedence over this one.                          (<strong>Default</strong> = 0)</p></li><li><p><code>minimum_columns_width</code>: A set of integers specifying the minimum width of                          each column. If the width is equal or lower than 0,                          then it will be ignored. If it is a single integer,                          then this number will be used as the minimum width                          of all columns. Notice that the parameter                          <code>columns_width</code> has precedence over this one.                          (<strong>Default</strong> = 0)</p></li><li><p><code>newline_at_end</code>: If <code>false</code>, then the table will not end with a newline                   character. (<strong>Default</strong> = <code>true</code>)</p></li><li><p><code>noheader</code>: If <code>true</code>, then the header will not be printed. Notice that all             keywords and parameters related to the header and sub-headers will             be ignored. (<strong>Default</strong> = <code>false</code>)</p></li><li><p><code>nosubheader</code>: If <code>true</code>, then the sub-header will not be printed, <em>i.e.</em> the                header will contain only one line. Notice that this option has                no effect if <code>noheader = true</code>. (<strong>Default</strong> = <code>false</code>)</p></li><li><p><code>omitted_cell_summary_crayon</code>: Crayon used to print the omitted cell summary.</p></li><li><p><code>overwrite</code>: If <code>true</code>, then the same number of lines in the printed table              will be deleted from the output <code>io</code>. This can be used to update              the table in the display continuously. (<strong>Default</strong> = <code>false</code>)</p></li><li><p><code>row_number_alignment</code>: Select the alignment of the row number column (see the                         section <code>Alignment</code>). (<strong>Default</strong> = <code>:r</code>)</p></li><li><p><code>row_number_column_title</code>: The title of the column that shows the row numbers.                            (<strong>Default</strong> = &quot;Row&quot;)</p></li><li><p><code>show_omitted_cell_summary</code>: If <code>true</code>, then a summary will be printed after                              the table with the number of columns and rows                              that were omitted. (<strong>Default</strong> = <code>true</code>)</p></li><li><p><code>show_row_number</code>: If <code>true</code>, then a new column will be printed showing the                    row number. (<strong>Default</strong> = <code>false</code>)</p></li><li><p><code>tf</code>: Table format used to print the table (see <code>TextFormat</code>).       (<strong>Default</strong> = <code>tf_unicode</code>)</p></li><li><p><code>title_autowrap</code>: If <code>true</code>, then the title text will be wrapped considering                   the title size. Otherwise, lines larger than the title size                   will be cropped. (<strong>Default</strong> = <code>false</code>)</p></li><li><p><code>title_crayon</code>: Crayon to print the title.</p></li><li><p><code>title_same_width_as_table</code>: If <code>true</code>, then the title width will match that                              of the table. Otherwise, the title size will be                              equal to the display width.                              (<strong>Default</strong> = <code>false</code>)</p></li><li><p><code>vcrop_mode</code>: This variable defines the vertical crop behavior. If it is               <code>:bottom</code>, then the data, if required, will be cropped in the               bottom. On the other hand, if it is <code>:middle</code>, then the data               will be cropped in the middle if necessary.               (<strong>Default</strong> = <code>:bottom</code>)</p></li><li><p><code>vlines</code>: This variable controls where the vertical lines will be drawn. It           can be <code>nothing</code>, <code>:all</code>, <code>:none</code> or a vector of integers.</p><ul><li>If it is <code>nothing</code>, which is the default, then the configuration will be obtained from the table format in the variable <code>tf</code> (see <code>TextFormat</code>).</li><li>If it is <code>:all</code>, then all vertical lines will be drawn.</li><li>If it is <code>:none</code>, then no vertical line will be drawn.</li><li>If it is a vector of integers, then the vertical lines will be drawn only after the columns in the vector. Notice that the top line will be drawn if <code>0</code> is in <code>vlines</code>. Furthermore, it is important to mention that the column number in this variable is related to the <strong>printed column</strong>. Thus, it is affected by filters, and by the options <code>row_names</code> and <code>show_row_number</code>. Finally, for convenience, the left and right vertical lines can be drawn by adding the symbols <code>:begin</code> and <code>:end</code> to this vector, respectively, and the line after the header can be drawn by adding the symbol <code>:header</code>.</li></ul><p>(<strong>Default</strong> = <code>nothing</code>)</p></li></ul><p>The keywords <code>header_crayon</code> and <code>subheader_crayon</code> can be a <code>Crayon</code> or a <code>Vector{Crayon}</code>. In the first case, the <code>Crayon</code> will be applied to all the elements. In the second, each element can have its own crayon, but the length of the vector must be equal to the number of columns in the data.</p><p><strong>Crayons</strong></p><p>A <code>Crayon</code> is an object that handles a style for text printed on terminals. It is defined in the package <a href="https://github.com/KristofferC/Crayons.jl">Crayons.jl</a>. There are many options available to customize the style, such as foreground color, background color, bold text, etc.</p><p>A <code>Crayon</code> can be created in two different ways:</p><pre><code class="language-julia-repl">julia&gt; Crayon(foreground = :blue, background = :black, bold = :true)

julia&gt; crayon&quot;blue bg:black bold&quot;</code></pre><p>For more information, see the package documentation.</p><p><strong>Text highlighters</strong></p><p>A set of highlighters can be passed as a <code>Tuple</code> to the <code>highlighters</code> keyword. Each highlighter is an instance of the structure <code>Highlighter</code> that contains three fields:</p><ul><li><code>f</code>: Function with the signature <code>f(data,i,j)</code> in which should return <code>true</code>      if the element <code>(i,j)</code> in <code>data</code> must be highlighter, or <code>false</code>      otherwise.</li><li><code>fd</code>: Function with the signature <code>f(h,data,i,j)</code> in which <code>h</code> is the       highlighter. This function must return the <code>Crayon</code> to be applied to the       cell that must be highlighted.</li><li><code>crayon</code>: The <code>Crayon</code> to be applied to the highlighted cell if the default           <code>fd</code> is used.</li></ul><p>The function <code>f</code> has the following signature:</p><pre><code class="language-none">f(data, i, j)</code></pre><p>in which <code>data</code> is a reference to the data that is being printed, and <code>i</code> and <code>j</code> are the element coordinates that are being tested. If this function returns <code>true</code>, then the cell <code>(i,j)</code> will be highlighted.</p><p>If the function <code>f</code> returns true, then the function <code>fd(h,data,i,j)</code> will be called and must return a <code>Crayon</code> that will be applied to the cell.</p><p>A highlighter can be constructed using three helpers:</p><pre><code class="language-none">Highlighter(f::Function; kwargs...)</code></pre><p>where it will construct a <code>Crayon</code> using the keywords in <code>kwargs</code> and apply it to the highlighted cell,</p><pre><code class="language-none">Highlighter(f::Function, crayon::Crayon)</code></pre><p>where it will apply the <code>crayon</code> to the highlighted cell, and</p><pre><code class="language-none">Highlighter(f::Function, fd::Function)</code></pre><p>where it will apply the <code>Crayon</code> returned by the function <code>fd</code> to the highlighted cell.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If only a single highlighter is wanted, then it can be passed directly to the keyword <code>highlighter</code> without being inside a <code>Tuple</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If multiple highlighters are valid for the element <code>(i,j)</code>, then the applied style will be equal to the first match considering the order in the tuple <code>highlighters</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the highlighters are used together with <a href="../../man/formatters/#Formatters">Formatters</a>, then the change in the format <strong>will not</strong> affect the parameter <code>data</code> passed to the highlighter function <code>f</code>. It will always receive the original, unformatted value.</p></div></div><hr/><p><strong>Pretty table HTML backend</strong></p><p>This backend produces HTML tables. This backend can be used by selecting <code>backend = :html</code>.</p><p><strong>Keywords</strong></p><ul><li><code>highlighters</code>: An instance of <code>HTMLHighlighter</code> or a tuple with a list of                 HTML highlighters (see the section <code>HTML highlighters</code>).</li><li><code>linebreaks</code>: If <code>true</code>, then <code>\n</code> will be replaced by <code>&lt;br&gt;</code>.               (<strong>Default</strong> = <code>false</code>)</li><li><code>noheader</code>: If <code>true</code>, then the header will not be printed. Notice that all             keywords and parameters related to the header and sub-headers will             be ignored. (<strong>Default</strong> = <code>false</code>)</li><li><code>nosubheader</code>: If <code>true</code>, then the sub-header will not be printed, <em>i.e.</em> the                header will contain only one line. Notice that this option has                no effect if <code>noheader = true</code>. (<strong>Default</strong> = <code>false</code>)</li><li><code>standalone</code>: If <code>true</code>, then a complete HTML page will be generated.               Otherwise, only the content between the tags <code>&lt;table&gt;</code> and               <code>&lt;/table&gt;</code> will be printed (with the tags included).               (<strong>Default</strong> = <code>true</code>)</li><li><code>tf</code>: An instance of the structure <code>HTMLTableFormat</code> that defines the general       format of the HTML table.</li></ul><p><strong>HTML highlighters</strong></p><p>A set of highlighters can be passed as a <code>Tuple</code> to the <code>highlighters</code> keyword. Each highlighter is an instance of the structure <a href="#PrettyTables.HTMLHighlighter"><code>HTMLHighlighter</code></a>. It contains the following two public fields:</p><ul><li><code>f</code>: Function with the signature <code>f(data,i,j)</code> in which should return <code>true</code>      if the element <code>(i,j)</code> in <code>data</code> must be highlighted, or <code>false</code>      otherwise.</li><li><code>fd</code>: Function with the signature <code>f(h,data,i,j)</code> in which <code>h</code> is the       highlighter. This function must return the <code>HTMLDecoration</code> to be       applied to the cell that must be highlighted.</li></ul><p>The function <code>f</code> has the following signature:</p><pre><code class="language-none">f(data, i, j)</code></pre><p>in which <code>data</code> is a reference to the data that is being printed, and <code>i</code> and <code>j</code> are the element coordinates that are being tested. If this function returns <code>true</code>, then the highlight style will be applied to the <code>(i,j)</code> element. Otherwise, the default style will be used.</p><p>If the function <code>f</code> returns true, then the function <code>fd(h,data,i,j)</code> will be called and must return an element of type <code>HTMLDecoration</code> that contains the decoration to be applied to the cell.</p><p>A HTML highlighter can be constructed using two helpers:</p><pre><code class="language-none">HTMLHighlighter(f::Function, decoration::HTMLDecoration)

HTMLHighlighter(f::Function, fd::Function)</code></pre><p>The first will apply a fixed decoration to the highlighted cell specified in <code>decoration</code> whereas the second let the user select the desired decoration by specifying the function <code>fd</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If only a single highlighter is wanted, then it can be passed directly to the keyword <code>highlighter</code> without being inside a <code>Tuple</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If multiple highlighters are valid for the element <code>(i,j)</code>, then the applied style will be equal to the first match considering the order in the tuple <code>highlighters</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the highlighters are used together with <a href="../../man/formatters/#Formatters">Formatters</a>, then the change in the format <strong>will not</strong> affect the parameter <code>data</code> passed to the highlighter function <code>f</code>. It will always receive the original, unformatted value.</p></div></div><hr/><p><strong>Pretty table LaTeX backend</strong></p><p>This backend produces LaTeX tables. This backend can be used by selecting <code>backend = :latex</code>.</p><p><strong>Keywords</strong></p><ul><li><p><code>body_hlines</code>: A vector of <code>Int</code> indicating row numbers in which an additional                horizontal line should be drawn after the row. Notice that                numbers lower than 1 and equal or higher than the number of                printed rows will be neglected. This vector will be appended to                the one in <code>hlines</code>, but the indices here are related to the                printed rows of the body. Thus, if <code>1</code> is added to                <code>body_hlines</code>, then a horizontal line will be drawn after the                first data row. (<strong>Default</strong> = <code>Int[]</code>)</p></li><li><p><code>highlighters</code>: An instance of <code>LatexHighlighter</code> or a tuple with a list of                 LaTeX highlighters (see the section <code>LaTeX highlighters</code>).</p></li><li><p><code>hlines</code>: This variable controls where the horizontal lines will be drawn. It           can be <code>nothing</code>, <code>:all</code>, <code>:none</code> or a vector of integers.</p><ul><li>If it is <code>nothing</code>, which is the default, then the configuration will be obtained from the table format in the variable <code>tf</code> (see <code>LatexTableFormat</code>).</li><li>If it is <code>:all</code>, then all horizontal lines will be drawn.</li><li>If it is <code>:none</code>, then no horizontal line will be drawn.</li><li>If it is a vector of integers, then the horizontal lines will be drawn only after the rows in the vector. Notice that the top line will be drawn if <code>0</code> is in <code>hlines</code>, and the header and subheaders are considered as only 1 row. Furthermore, it is important to mention that the row number in this variable is related to the <strong>printed rows</strong>. Thus, it is affected by filters, and by the option to suppress the header <code>noheader</code>. Finally, for convenience, the top and bottom lines can be drawn by adding the symbols <code>:begin</code> and <code>:end</code> to this vector, respectively, and the line after the header can be drawn by adding the symbol <code>:header</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The values of <code>body_hlines</code> will be appended to this vector. Thus, horizontal lines can be drawn even if <code>hlines</code> is <code>:none</code>.</p></div></div><p>(<strong>Default</strong> = <code>nothing</code>)</p></li><li><p><code>longtable_footer</code>: The string that will be drawn in the footer of the tables                     before a page break. This only works if <code>table_type</code> is                     <code>:longtable</code>. If it is <code>nothing</code>, then no footer will be                     used. (<strong>Default</strong> = <code>nothing</code>)</p></li><li><p><code>noheader</code>: If <code>true</code>, then the header will not be printed. Notice that all             keywords and parameters related to the header and sub-headers will             be ignored. (<strong>Default</strong> = <code>false</code>)</p></li><li><p><code>nosubheader</code>: If <code>true</code>, then the sub-header will not be printed, <em>i.e.</em> the                header will contain only one line. Notice that this option has                no effect if <code>noheader = true</code>. (<strong>Default</strong> = <code>false</code>)</p></li><li><p><code>row_number_alignment</code>: Select the alignment of the row number column (see the                         section <code>Alignment</code>). (<strong>Default</strong> = <code>:r</code>)</p></li><li><p><code>table_type</code>: Select which LaTeX environment will be used to print the table.               Currently supported options are <code>:tabular</code> for <code>tabular</code> or               <code>:longtable</code> for <code>longtable</code>. If it is <code>nothing</code> then the               default option of the table format will be used.               (<strong>Default</strong> = <code>nothing</code>)</p></li><li><p><code>tf</code>: An instance of the structure <code>LatexTableFormat</code> that defines the general       format of the LaTeX table.</p></li><li><p><code>vlines</code>: This variable controls where the vertical lines will be drawn. It           can be <code>:all</code>, <code>:none</code> or a vector of integers. In the first case           (the default behavior), all vertical lines will be drawn. In the           second case, no vertical line will be drawn. In the third case,           the vertical lines will be drawn only after the columns in the           vector. Notice that the left border will be drawn if <code>0</code> is in           <code>vlines</code>. Furthermore, it is important to mention that the column           number in this variable is related to the <strong>printed columns</strong>. Thus,           it is affected by filters, and by the columns added using the           variable <code>show_row_number</code>. Finally, for convenience, the left and           right border can be drawn by adding the symbols <code>:begin</code> and <code>:end</code>           to this vector, respectively. (<strong>Default</strong> = <code>:none</code>)</p></li><li><p><code>wrap_table</code>: This variable controls whether to wrap the table in a               environment defined by the variable <code>wrap_table_environment</code>.               Defaults to <code>true</code>. When <code>false</code>, the printed table begins with               <code>egin{tabular}</code>. This option does not work with <code>:longtable</code>.               If it is <code>nothing</code> then the default option of the table format               will be used. (<strong>Default</strong> = <code>nothing</code>)</p></li><li><p><code>wrap_table_environment</code>: Environment that will be used to wrap the table if                           the option <code>wrap_table</code> is <code>true</code>. If it is                           <code>nothing</code> then the default option of the table                           format will be used. (<strong>Default</strong> = <code>nothing</code>)</p></li></ul><p><strong>LaTeX highlighters</strong></p><p>A set of highlighters can be passed as a <code>Tuple</code> to the <code>highlighters</code> keyword. Each highlighter is an instance of the structure <code>LatexHighlighter</code>. It contains the following two fields:</p><ul><li><code>f</code>: Function with the signature <code>f(data,i,j)</code> in which should return <code>true</code>      if the element <code>(i,j)</code> in <code>data</code> must be highlighted, or <code>false</code>      otherwise.</li><li><code>fd</code>: A function with the signature <code>f(data,i,j,str)::String</code> in which       <code>data</code> is the matrix, <code>(i,j)</code> is the element position in the table, and       <code>str</code> is the data converted to string. This function must return a       string that will be placed in the cell.</li></ul><p>The function <code>f</code> has the following signature:</p><pre><code class="language-none">f(data, i, j)</code></pre><p>in which <code>data</code> is a reference to the data that is being printed, <code>i</code> and <code>j</code> are the element coordinates that are being tested. If this function returns <code>true</code>, then the highlight style will be applied to the <code>(i,j)</code> element. Otherwise, the default style will be used.</p><p>If the function <code>f</code> returns true, then the function <code>fd(data,i,j,str)</code> will be called and must return the LaTeX string that will be placed in the cell.</p><p>There are two helpers that can be used to create LaTeX highlighters:</p><pre><code class="language-none">LatexHighlighter(f::Function, envs::Union{String,Vector{String}})

LatexHighlighter(f::Function, fd::Function)</code></pre><p>The first will apply recursively all the LaTeX environments in <code>envs</code> to the highlighted text whereas the second let the user select the desired decoration by specifying the function <code>fd</code>.</p><p>Thus, for example:</p><pre><code class="language-none">LatexHighlighter((data,i,j)-&gt;true, [&quot;textbf&quot;, &quot;small&quot;])</code></pre><p>will wrap all the cells in the table in the following environment:</p><pre><code class="language-none">\textbf{\small{&lt;Cell text&gt;}}</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If only a single highlighter is wanted, then it can be passed directly to the keyword <code>highlighter</code> without being inside a <code>Tuple</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If multiple highlighters are valid for the element <code>(i,j)</code>, then the applied style will be equal to the first match considering the order in the tuple <code>highlighters</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the highlighters are used together with <a href="../../man/formatters/#Formatters">Formatters</a>, then the change in the format <strong>will not</strong> affect the parameter <code>data</code> passed to the highlighter function <code>f</code>. It will always receive the original, unformatted value.</p></div></div><hr/><p><strong>Formatters</strong></p><p>The keyword <code>formatters</code> can be used to pass functions to format the values in the columns. It must be a tuple of functions in which each function has the following signature:</p><pre><code class="language-none">f(v, i, j)</code></pre><p>where <code>v</code> is the value in the cell, <code>i</code> is the row number, and <code>j</code> is the column number. Thus, it must return the formatted value of the cell <code>(i,j)</code> that has the value <code>v</code>. Notice that the returned value will be converted to string after using the function <code>sprint</code>.</p><p>This keyword can also be a single function, meaning that only one formatter is available, or <code>nothing</code>, meaning that no formatter will be used.</p><p>For example, if we want to multiply all values in odd rows of the column 2 by π, then the formatter should look like:</p><pre><code class="language-none">formatters = (v,i,j) -&gt; (j == 2 &amp;&amp; isodd(i)) ? v*π : v</code></pre><p>If multiple formatters are available, then they will be applied in the same order as they are located in the tuple. Thus, for the following <code>formatters</code>:</p><pre><code class="language-none">formatters = (f1, f2, f3)</code></pre><p>each element <code>v</code> in the table (i-th row and j-th column) will be formatted by:</p><pre><code class="language-none">v = f1(v,i,j)
v = f2(v,i,j)
v = f3(v,i,j)</code></pre><p>Thus, the user must be ensure that the type of <code>v</code> between the calls are compatible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/print.jl#L15-L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.pretty_table_with_conf-Tuple{PrettyTablesConf,Vararg{Any,N} where N}" href="#PrettyTables.pretty_table_with_conf-Tuple{PrettyTablesConf,Vararg{Any,N} where N}"><code>PrettyTables.pretty_table_with_conf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pretty_table_with_conf(conf::PrettyTablesConf, args...; kwargs...)</code></pre><p>Call <code>pretty_table</code> using the default configuration in <code>conf</code>. The <code>args...</code> and <code>kwargs...</code> can be the same as those passed to <code>pretty_tables</code>. Notice that all the configurations in <code>kwargs...</code> will overwrite the ones in <code>conf</code>.</p><p>The object <code>conf</code> can be created by the function <code>set_pt_conf</code> in which the keyword parameters can be any one supported by the function <code>pretty_table</code> as shown in the following.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/configuration.jl#L16-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.set_pt_conf!-Tuple{PrettyTablesConf}" href="#PrettyTables.set_pt_conf!-Tuple{PrettyTablesConf}"><code>PrettyTables.set_pt_conf!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_pt_conf!(conf; kwargs...)</code></pre><p>Apply the configurations in <code>kwargs</code> to the object <code>conf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/configuration.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.set_pt_conf-Tuple{}" href="#PrettyTables.set_pt_conf-Tuple{}"><code>PrettyTables.set_pt_conf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_pt_conf(;kwargs...)</code></pre><p>Create a new configuration object based on the arguments in <code>kwargs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/configuration.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.@pt-Tuple" href="#PrettyTables.@pt-Tuple"><code>PrettyTables.@pt</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@pt(expr...)</code></pre><p>Pretty print tables in <code>expr</code> to <code>stdout</code> using the global configurations selected with the macro <code>@ptconf</code>.</p><p>Multiple tables can be printed by passing multiple expressions like:</p><pre><code class="language-none">@pt table1 table2 table3</code></pre><p>The user can select the table header by passing the expression:</p><pre><code class="language-none">:header = [&lt;Vector with the header&gt;]</code></pre><p>Notice that the header is valid only for the next printed table. Hence:</p><pre><code class="language-none">@pt :header = header1 table1 :header = header2 table2 table3</code></pre><p>will print <code>table1</code> using <code>header1</code>, <code>table2</code> using <code>header2</code>, and <code>table3</code> using the default header.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; @ptconf tf = simple

julia&gt; @pt :header = [&quot;Time&quot;,&quot;Velocity&quot;] [1:1:10 ones(10)] :header = [&quot;Time&quot;,&quot;Position&quot;] [1:1:10 1:1:10]
======= ===========
  Time   Velocity
======= ===========
   1.0        1.0
   2.0        1.0
   3.0        1.0
   4.0        1.0
   5.0        1.0
   6.0        1.0
   7.0        1.0
   8.0        1.0
   9.0        1.0
  10.0        1.0
======= ===========
======= ===========
  Time   Position
======= ===========
     1          1
     2          2
     3          3
     4          4
     5          5
     6          6
     7          7
     8          8
     9          9
    10         10
======= ===========

julia&gt; @pt ones(3,3) + I + [1 2 3; 4 5 6; 7 8 9]
========= ======== =========
  Col. 1   Col. 2   Col. 3
========= ======== =========
     3.0      3.0      4.0
     5.0      7.0      7.0
     8.0      9.0     11.0
========= ======== =========</code></pre><p><strong>Remarks</strong></p><p>When more than one table is passed to this macro, then multiple calls to <code>pretty_table</code> will occur. Hence, the cropping algorithm will behave exactly the same as printing the tables separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/helpers.jl#L60-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.@ptconf-Tuple" href="#PrettyTables.@ptconf-Tuple"><code>PrettyTables.@ptconf</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@ptconf(expr...)</code></pre><p>Add configurations in <code>expr</code> to be used with the macro <code>@pt</code>.</p><p>The expression format must be:</p><pre><code class="language-none">keyword1 = value1 keyword2 = value2 ...</code></pre><p>in which the keywords can be any other possible keyword that can be used in the function <code>pretty_table</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If a keyword is not supported by the function <code>pretty_table</code>, then no error message is printed when calling <code>@ptconf</code>. However, an error will be thrown when <code>@pt</code> is called.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/helpers.jl#L25-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PrettyTables.@ptconfclean-Tuple{}" href="#PrettyTables.@ptconfclean-Tuple{}"><code>PrettyTables.@ptconfclean</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@ptconfclean()</code></pre><p>Clean all global configurations to pretty print tables using the macro <code>@pt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ronisbr/PrettyTables.jl/blob/ea6270f1f895bc63270e79baac171e693adc7a9e/src/helpers.jl#L14-L19">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/html_examples/">« HTML back-end</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 14 January 2021 11:56">Thursday 14 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
